name: CI-CD Backend

on:
  push:
    branches: ['master']
  pull_request:
    branches: ['master']

jobs:
  quality_and_build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci


      - name: Lint
        run: npm run lint

      - name: Type check
        run: npx tsc --noEmit

  tests:
    runs-on: ubuntu-latest
    needs: quality_and_build

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: collector_test
          POSTGRES_PASSWORD: collector_test
          POSTGRES_DB: collector_test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U collector_test -d collector_test_db"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    env:
      KEYCLOAK_ISSUER: http://localhost:8081/realms/collector
      KEYCLOAK_CLIENT_ID: collector-api
      KEYCLOAK_CLIENT_SECRET: dummy-secret

      DB_HOST: 127.0.0.1
      DB_PORT: "5432"
      DB_USER: collector_test
      DB_PASSWORD: collector_test
      DB_NAME: collector_test_db

      NODE_ENV: test

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm ci

      - name: Wait for Postgres
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          for i in {1..30}; do
            pg_isready -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" && exit 0
            echo "Postgres not ready yet... ($i/30)"
            sleep 2
          done
          echo "Postgres did not become ready in time" && exit 1

      - name: Unit tests
        run: npm test

      - name: E2E API tests
        run: npm run test:e2e

  security:
    runs-on: ubuntu-latest
    needs: tests
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm ci

      - name: Tests with coverage
        run: npm run test:cov

      - name: SonarQube Cloud Scan
        uses: SonarSource/sonarqube-scan-action@v7
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  build_and_docker:
    runs-on: ubuntu-latest
    needs: security
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci

      - name: Build app
        run: npm run build

      - name: Build Docker image
        run: |
          docker build -t ghcr.io/${{ github.repository_owner }}/collector-api:${{ github.sha }} .

  # charge_test:
  #   runs-on: ubuntu-latest
  #   # needs: build_and_docker
  #   env:
  #     TARGET_URL: http://localhost:4000
  #     KEYCLOAK_ISSUER: http://localhost:8081/realms/collector
  #     KEYCLOAK_CLIENT_ID: collector-api
  #     KEYCLOAK_CLIENT_SECRET: ${{ secrets.KEYCLOAK_CLIENT_SECRET }}
  #   steps:
  #     - name: Install siege and jq
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y siege jq

  #     - name: Create Siege URL file
  #       run: |
  #         cat > siege-urls.txt <<EOF
  #         ${TARGET_URL}/users
  #         ${TARGET_URL}/notifications/my
  #         ${TARGET_URL}/articles
  #         EOF

  #             - name: Get access token from Keycloak
  #               run: |
  #                 TOKEN=$(curl -s \
  #                   -H "Content-Type: application/x-www-form-urlencoded" \
  #                   -d "client_id=${KEYCLOAK_CLIENT_ID}" \
  #                   -d "client_secret=${KEYCLOAK_CLIENT_SECRET}" \
  #                   -d "grant_type=client_credentials" \
  #                   "${KEYCLOAK_ISSUER}/protocol/openid-connect/token" \
  #                   | jq -r .access_token)

  #                 echo "TOKEN=$TOKEN"
  #                 echo "TOKEN=$TOKEN" >> $GITHUB_ENV

  #             - name: Run load tests on multiple API endpoints
  #               run: |
  #                 echo "Running load tests on endpoints from siege-urls.txt..."
  #                 siege -c 3 -t1M \
  #                   -H "Authorization: Bearer $TOKEN" \
  #                   -H "Content-Type: application/json" \
  #                   -f siege-urls.txt

  owasp_zap:
      runs-on: ubuntu-latest
      env:
        API_PORT: 4000
        API_BASE_URL: http://127.0.0.1:4000
        KEYCLOAK_HOST: collector-keycloak
        KEYCLOAK_HTTP_PORT: 8080
        KEYCLOAK_ISSUER: http://collector-keycloak:8080/realms/collector
        KEYCLOAK_CLIENT_ID: collector-api
        KEYCLOAK_CLIENT_SECRET: ${{ secrets.KEYCLOAK_CLIENT_SECRET }}
        DB_HOST: collector-postgres
        DB_PORT: 5432
        DB_USER: collector_user
        DB_PASSWORD: collector_password
        DB_NAME: collector_db

      steps:
        - name: Checkout
          uses: actions/checkout@v4

        # -----------------------------
        # 1) npm audit (safe by default)
        # -----------------------------
        - name: Setup Node
          uses: actions/setup-node@v4
          with:
            node-version: 20
            cache: "npm"

        - name: Install dependencies
          run: npm ci

        - name: npm audit (report, non-bloquant)
          run: |
            set -e
            npm audit --audit-level=high --json > npm-audit.json || true
            echo "npm audit report generated: npm-audit.json"
            # Si tu veux rendre bloquant plus tard :
            # npm audit --audit-level=critical

        - name: Upload npm audit report
          uses: actions/upload-artifact@v4
          with:
            name: npm-audit-report
            path: npm-audit.json

        - name: Build API Docker image
          run: |
            docker build -t collector-api:${{ github.sha }} .

        - name: Create CI Docker network
          run: docker network create ci-net

        - name: Run Postgres for API
          run: |
            docker run -d --name collector-postgres \
              --network ci-net \
              -e POSTGRES_USER=${DB_USER} \
              -e POSTGRES_PASSWORD=${DB_PASSWORD} \
              -e POSTGRES_DB=${DB_NAME} \
              -p 5433:5432 \
              postgres:14

            echo "Waiting for Postgres..."
            for i in {1..30}; do
              if docker exec collector-postgres pg_isready -U ${DB_USER} -d ${DB_NAME}; then
                echo "Postgres ready"
                exit 0
              fi
              sleep 2
            done
            echo "Postgres not ready"; docker logs collector-postgres; exit 1

        - name: Run Keycloak
          run: |
            docker run -d --name collector-keycloak \
              --network ci-net \
              -e KEYCLOAK_ADMIN=admin \
              -e KEYCLOAK_ADMIN_PASSWORD=admin \
              -e KC_HOSTNAME=${KEYCLOAK_HOST} \
              -p 8081:8080 \
              quay.io/keycloak/keycloak:24.0.5 \
              start-dev

            echo "Waiting for Keycloak..."
            curl --fail --retry 30 --retry-all-errors --retry-delay 3 \
              http://127.0.0.1:8081/realms/master/.well-known/openid-configuration

        - name: Configure Keycloak (create realm + client)
          run: |
            set -e

            # Login admin
            docker exec collector-keycloak /opt/keycloak/bin/kcadm.sh config credentials \
              --server http://127.0.0.1:8080 \
              --realm master \
              --user admin \
              --password admin

            # Create realm "collector" if not exists
            docker exec collector-keycloak /opt/keycloak/bin/kcadm.sh get realms/collector >/dev/null 2>&1 \
              || docker exec collector-keycloak /opt/keycloak/bin/kcadm.sh create realms \
                -s realm=collector -s enabled=true

            # Create client "collector-api" (service account enabled) if not exists
            CLIENT_UUID=$(docker exec collector-keycloak /opt/keycloak/bin/kcadm.sh get clients -r collector \
              -q clientId=${KEYCLOAK_CLIENT_ID} --fields id --format csv | tail -n 1 | tr -d '\r')

            if [ -z "$CLIENT_UUID" ]; then
              docker exec collector-keycloak /opt/keycloak/bin/kcadm.sh create clients -r collector \
                -s clientId=${KEYCLOAK_CLIENT_ID} \
                -s enabled=true \
                -s publicClient=false \
                -s serviceAccountsEnabled=true \
                -s directAccessGrantsEnabled=true \
                -s standardFlowEnabled=false \
                -s secret="${KEYCLOAK_CLIENT_SECRET}"
            else
              # Ensure secret is set (update client secret)
              docker exec collector-keycloak /opt/keycloak/bin/kcadm.sh update clients/${CLIENT_UUID} -r collector \
                -s secret="${KEYCLOAK_CLIENT_SECRET}" \
                -s serviceAccountsEnabled=true
            fi

            echo "Keycloak realm+client ready."

        - name: Run API container for ZAP
          run: |
            docker run -d --name collector-api \
              --network ci-net \
              -p ${API_PORT}:4000 \
              -e PORT=4000 \
              -e DB_HOST=${DB_HOST} \
              -e DB_PORT=${DB_PORT} \
              -e DB_USER=${DB_USER} \
              -e DB_PASSWORD=${DB_PASSWORD} \
              -e DB_NAME=${DB_NAME} \
              -e KEYCLOAK_ISSUER=${KEYCLOAK_ISSUER} \
              -e KEYCLOAK_JWKS_URI=${KEYCLOAK_ISSUER}/protocol/openid-connect/certs \
              -e KEYCLOAK_AUDIENCE=${KEYCLOAK_CLIENT_ID} \
              collector-api:${{ github.sha }}

        - name: Wait for API to be up (with logs on failure)
          run: |
            set +e
            for i in {1..30}; do
              if curl -fsS ${API_BASE_URL}/health >/dev/null 2>&1; then
                echo "API is up"
                exit 0
              fi
              echo "API not ready yet... (try $i/30)"
              docker logs --tail=80 collector-api || true
              sleep 3
            done

            echo "API never became ready"
            docker ps -a || true
            docker logs collector-api || true
            exit 1

        - name: Install jq
          run: |
            sudo apt-get update
            sudo apt-get install -y jq

        - name: Get Keycloak token for ZAP (client_credentials)
          run: |
            TOKEN=$(curl -s \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "client_id=${KEYCLOAK_CLIENT_ID}" \
              -d "client_secret=${KEYCLOAK_CLIENT_SECRET}" \
              -d "grant_type=client_credentials" \
              "http://127.0.0.1:8081/realms/collector/protocol/openid-connect/token" \
              | jq -r .access_token)

            if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
              echo "Failed to get token"; exit 1
            fi

            echo "TOKEN=$TOKEN" >> $GITHUB_ENV

        - name: OWASP ZAP baseline scan (secured endpoints)
          uses: zaproxy/action-baseline@v0.15.0
          env:
            ZAP_AUTH_HEADER: Authorization
            ZAP_AUTH_HEADER_VALUE: Bearer ${{ env.TOKEN }}
          with:
            target: '${{ env.API_BASE_URL }}/articles'
            docker_name: 'ghcr.io/zaproxy/zaproxy:stable'
            cmd_options: '-a'
            fail_action: false

        - name: Cleanup containers
          if: always()
          run: |
            docker logs collector-api || true
            docker rm -f collector-api collector-keycloak collector-postgres || true
            docker network rm ci-net || true

  deploy_staging_k8s:
    runs-on: ubuntu-latest
    needs: build_and_docker

    steps:
      - uses: actions/checkout@v4

      - name: Create kind cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: staging

      - name: Build Docker image
        run: |
          docker build -t collector-api:ci .

      - name: Load image into kind
        run: |
          kind load docker-image collector-api:ci --name staging

      - name: Deploy to Kubernetes (staging)
        shell: bash
        run: |
          set -e
          kubectl apply -f k8s/staging.yaml

          kubectl -n staging rollout status deploy/postgres --timeout=180s
          kubectl -n staging rollout status deploy/api --timeout=180s

          kubectl -n staging wait --for=condition=Ready pod -l app=postgres --timeout=180s
          kubectl -n staging wait --for=condition=Ready pod -l app=api --timeout=180s

      - name: Smoke test API (inside cluster, no port-forward)
        shell: bash
        run: |
          set -e
          kubectl -n staging run curltest --rm -i --restart=Never \
            --image=curlimages/curl:8.5.0 \
            --command -- sh -lc '
              for i in $(seq 1 20); do
                code=$(curl -s -o /dev/null -w "%{http_code}" http://api:4000/articles || true)
                echo "try $i => HTTP $code"
                if [ "$code" != "000" ]; then
                  echo "API reachable (HTTP $code)"
                  exit 0
                fi
                sleep 2
              done
              echo "API not reachable"
              exit 1
            '

  deploy_staging_https_test:
      name: Deploy staging (HTTPS test) - TEMP
      runs-on: ubuntu-latest
      needs: deploy_staging_k8s
      env:
        K8S_NAMESPACE: staging
        HOST: api.staging.local

      steps:
        - uses: actions/checkout@v4

        - name: Create kind cluster
          uses: helm/kind-action@v1.10.0
          with:
            cluster_name: staging

        - name: Label kind node for ingress-nginx
          shell: bash
          run: |
            set -euo pipefail
            kubectl get nodes -o wide
            NODE=$(kubectl get nodes -o jsonpath='{.items[0].metadata.name}')
            kubectl label node "$NODE" ingress-ready=true --overwrite
            echo "Labeled node: $NODE with ingress-ready=true"

        - name: Ensure namespace exists
          shell: bash
          run: |
            set -euo pipefail
            kubectl create namespace "${K8S_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f -

        - name: Build + Load + Deploy app
          shell: bash
          run: |
            set -euo pipefail

            DOCKER_BUILDKIT=1 docker build --progress=plain -t collector-api:ci .
            kind load docker-image collector-api:ci --name staging

            kubectl apply -f k8s/staging.yaml

            kubectl -n "${K8S_NAMESPACE}" rollout status deploy/postgres --timeout=300s || true
            kubectl -n "${K8S_NAMESPACE}" rollout status deploy/api --timeout=300s

            kubectl -n "${K8S_NAMESPACE}" get pods,svc -o wide

        - name: Install Ingress NGINX (Kind)
          shell: bash
          run: |
            set -euo pipefail

            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.11.3/deploy/static/provider/kind/deploy.yaml

            echo "Waiting admission jobs..."
            kubectl -n ingress-nginx wait --for=condition=complete job/ingress-nginx-admission-create --timeout=300s || true
            kubectl -n ingress-nginx wait --for=condition=complete job/ingress-nginx-admission-patch --timeout=300s || true

            echo "Waiting controller rollout..."
            kubectl -n ingress-nginx rollout status deploy/ingress-nginx-controller --timeout=420s

            kubectl -n ingress-nginx get pods,svc -o wide

        - name: Create self-signed TLS cert (TEMP)
          shell: bash
          run: |
            set -euo pipefail
            sudo apt-get update
            sudo apt-get install -y openssl

            openssl req -x509 -nodes -days 2 -newkey rsa:2048 \
              -keyout tls.key -out tls.crt \
              -subj "/CN=${HOST}/O=collector"

            kubectl -n "${K8S_NAMESPACE}" delete secret api-tls --ignore-not-found
            kubectl -n "${K8S_NAMESPACE}" create secret tls api-tls --cert=tls.crt --key=tls.key

        - name: Apply HTTPS Ingress (TEMP)
          shell: bash
          run: |
            set -euo pipefail

            cat <<EOF | kubectl apply -f -
            apiVersion: networking.k8s.io/v1
            kind: Ingress
            metadata:
              name: api-https
              namespace: ${K8S_NAMESPACE}
              annotations:
                nginx.ingress.kubernetes.io/ssl-redirect: "true"
            spec:
              ingressClassName: nginx
              tls:
                - hosts:
                    - ${HOST}
                  secretName: api-tls
              rules:
                - host: ${HOST}
                  http:
                    paths:
                      - path: /
                        pathType: Prefix
                        backend:
                          service:
                            name: api
                            port:
                              number: 4000
            EOF

            kubectl -n "${K8S_NAMESPACE}" get ing api-https -o wide

        - name: HTTPS smoke test (via port-forward) - TEMP
          shell: bash
          run: |
            set -euo pipefail

            cleanup() { kill "${PF_PID:-}" >/dev/null 2>&1 || true; }
            trap cleanup EXIT

            kubectl -n ingress-nginx port-forward svc/ingress-nginx-controller 8443:443 >/tmp/pf.log 2>&1 &
            PF_PID=$!
            sleep 5

            echo "Testing HTTPS on https://127.0.0.1:8443 with Host=${HOST}"

            ok_codes="200 204 301 302 401 403"

            for i in $(seq 1 30); do
              code=$(curl -k -s -o /dev/null -w "%{http_code}" \
                "https://127.0.0.1:8443/articles" -H "Host: ${HOST}" || true)

              echo "try $i => HTTPS $code"
              if echo "$ok_codes" | grep -qw "$code"; then
                echo "HTTPS reachable (HTTP $code)"
                exit 0
              fi
              sleep 2
            done

            echo "HTTPS not reachable"
            echo "==== Port-forward logs ===="
            tail -200 /tmp/pf.log || true
            echo "==== Debug ingress-nginx ===="
            kubectl -n ingress-nginx get pods,svc -o wide || true
            kubectl -n ingress-nginx logs deploy/ingress-nginx-controller --tail=200 || true
            echo "==== Debug app ===="
            kubectl -n "${K8S_NAMESPACE}" get pods,svc,ing -o wide || true
            kubectl -n "${K8S_NAMESPACE}" describe ing api-https || true
            kubectl -n "${K8S_NAMESPACE}" logs deploy/api --tail=200 || true
            exit 1
