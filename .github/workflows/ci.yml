name: CI-CD Backend

on:
  push:
    branches: ['master']
  pull_request:
    branches: ['master']

jobs:
  quality_and_build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci


      - name: Lint
        run: npm run lint

      - name: Type check
        run: npx tsc --noEmit

  tests:
    runs-on: ubuntu-latest
    needs: quality_and_build

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: collector_test
          POSTGRES_PASSWORD: collector_test
          POSTGRES_DB: collector_test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U collector_test -d collector_test_db"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    env:
      KEYCLOAK_ISSUER: http://localhost:8081/realms/collector
      KEYCLOAK_CLIENT_ID: collector-api
      KEYCLOAK_CLIENT_SECRET: dummy-secret

      DB_HOST: 127.0.0.1
      DB_PORT: "5432"
      DB_USER: collector_test
      DB_PASSWORD: collector_test
      DB_NAME: collector_test_db

      NODE_ENV: test

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm ci

      - name: Wait for Postgres
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          for i in {1..30}; do
            pg_isready -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" && exit 0
            echo "Postgres not ready yet... ($i/30)"
            sleep 2
          done
          echo "Postgres did not become ready in time" && exit 1

      - name: Unit tests
        run: npm test

      - name: E2E API tests
        run: npm run test:e2e

  security:
    runs-on: ubuntu-latest
    needs: tests
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm ci

      - name: Tests with coverage
        run: npm run test:cov

      - name: SonarQube Cloud Scan
        uses: SonarSource/sonarqube-scan-action@v7
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  build_and_docker:
    runs-on: ubuntu-latest
    needs: security
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci

      - name: Build app
        run: npm run build

      - name: Build Docker image
        run: |
          docker build -t ghcr.io/${{ github.repository_owner }}/collector-api:${{ github.sha }} .

  # charge_test:
  #   runs-on: ubuntu-latest
  #   # needs: build_and_docker
  #   env:
  #     TARGET_URL: http://localhost:4000
  #     KEYCLOAK_ISSUER: http://localhost:8081/realms/collector
  #     KEYCLOAK_CLIENT_ID: collector-api
  #     KEYCLOAK_CLIENT_SECRET: ${{ secrets.KEYCLOAK_CLIENT_SECRET }}
  #   steps:
  #     - name: Install siege and jq
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y siege jq

  #     - name: Create Siege URL file
  #       run: |
  #         cat > siege-urls.txt <<EOF
  #         ${TARGET_URL}/users
  #         ${TARGET_URL}/notifications/my
  #         ${TARGET_URL}/articles
  #         EOF

  #             - name: Get access token from Keycloak
  #               run: |
  #                 TOKEN=$(curl -s \
  #                   -H "Content-Type: application/x-www-form-urlencoded" \
  #                   -d "client_id=${KEYCLOAK_CLIENT_ID}" \
  #                   -d "client_secret=${KEYCLOAK_CLIENT_SECRET}" \
  #                   -d "grant_type=client_credentials" \
  #                   "${KEYCLOAK_ISSUER}/protocol/openid-connect/token" \
  #                   | jq -r .access_token)

  #                 echo "TOKEN=$TOKEN"
  #                 echo "TOKEN=$TOKEN" >> $GITHUB_ENV

  #             - name: Run load tests on multiple API endpoints
  #               run: |
  #                 echo "Running load tests on endpoints from siege-urls.txt..."
  #                 siege -c 3 -t1M \
  #                   -H "Authorization: Bearer $TOKEN" \
  #                   -H "Content-Type: application/json" \
  #                   -f siege-urls.txt

  # owasp_zap:
  #   runs-on: ubuntu-latest
  #   # needs: charge_test
  #   env:
  #     API_PORT: 4000
  #     API_BASE_URL: http://localhost:4000
  #     KEYCLOAK_HOST: collector-keycloak
  #     KEYCLOAK_HTTP_PORT: 8080
  #     KEYCLOAK_ISSUER: http://collector-keycloak:8080/realms/collector
  #     KEYCLOAK_CLIENT_ID: collector-api
  #     KEYCLOAK_CLIENT_SECRET: ${{ secrets.KEYCLOAK_CLIENT_SECRET }}
  #     DB_HOST: collector-postgres
  #     DB_PORT: 5432
  #     DB_USER: collector_user
  #     DB_PASSWORD: collector_password
  #     DB_NAME: collector_db
  #   steps:
  #     - name: Checkout
  #     # ton code
  #       uses: actions/checkout@v4

  #     - name: Build API Docker image
  #       run: |
  #         docker build -t collector-api:${{ github.sha }} .

  #     - name: Create CI Docker network
  #       run: |
  #         docker network create ci-net

  #     - name: Run Postgres for API & Keycloak
  #       run: |
  #         docker run -d --name collector-postgres \
  #           --network ci-net \
  #           -e POSTGRES_USER=${DB_USER} \
  #           -e POSTGRES_PASSWORD=${DB_PASSWORD} \
  #           -e POSTGRES_DB=${DB_NAME} \
  #           -p 5433:5432 \
  #           postgres:14

  #     - name: Run Keycloak
  #       run: |
  #         docker run -d --name collector-keycloak \
  #           --network ci-net \
  #           -e KEYCLOAK_ADMIN=admin \
  #           -e KEYCLOAK_ADMIN_PASSWORD=admin \
  #           -e KC_DB=postgres \
  #           -e KC_DB_URL_HOST=${DB_HOST} \
  #           -e KC_DB_URL_DATABASE=${DB_NAME} \
  #           -e KC_DB_USERNAME=${DB_USER} \
  #           -e KC_DB_PASSWORD=${DB_PASSWORD} \
  #           -e KC_HOSTNAME=${KEYCLOAK_HOST} \
  #           -p 8081:8080 \
  #           quay.io/keycloak/keycloak:24.0.5 \
  #           start-dev

  #         echo "Waiting for Keycloak..."
  #         curl --fail --retry 20 --retry-all-errors --retry-delay 5 \
  #           http://localhost:8081/realms/master/.well-known/openid-configuration

  #     - name: Run API container for ZAP
  #       run: |
  #         docker run -d --name collector-api \
  #           --network ci-net \
  #           -p ${API_PORT}:4000 \
  #           -e PORT=${API_PORT} \
  #           -e DB_HOST=${DB_HOST} \
  #           -e DB_PORT=${DB_PORT} \
  #           -e DB_USER=${DB_USER} \
  #           -e DB_PASSWORD=${DB_PASSWORD} \
  #           -e DB_NAME=${DB_NAME} \
  #           -e KEYCLOAK_ISSUER=${KEYCLOAK_ISSUER} \
  #           -e KEYCLOAK_JWKS_URI=${KEYCLOAK_ISSUER}/protocol/openid-connect/certs \
  #           -e KEYCLOAK_AUDIENCE=${KEYCLOAK_CLIENT_ID} \
  #           collector-api:${{ github.sha }}

  #         echo "Waiting for API to be up..."
  #         curl --fail --retry 20 --retry-all-errors --retry-delay 5 \
  #           ${API_BASE_URL}/health

  #     - name: Install jq
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y jq

  #     - name: Get Keycloak token for ZAP (client_credentials)
  #       run: |
  #         TOKEN=$(curl -s \
  #           -H "Content-Type: application/x-www-form-urlencoded" \
  #           -d "client_id=${KEYCLOAK_CLIENT_ID}" \
  #           -d "client_secret=${KEYCLOAK_CLIENT_SECRET}" \
  #           -d "grant_type=client_credentials" \
  #           "http://localhost:8081/realms/collector/protocol/openid-connect/token" \
  #           | jq -r .access_token)

  #         echo "TOKEN=$TOKEN" >> $GITHUB_ENV

  #     - name: OWASP ZAP baseline scan (secured endpoints)
  #       uses: zaproxy/action-baseline@v0.15.0
  #       env:
  #         ZAP_AUTH_HEADER: Authorization
  #         ZAP_AUTH_HEADER_VALUE: Bearer ${{ env.TOKEN }}
  #       with:
  #         target: '${{ env.API_BASE_URL }}/articles'
  #         docker_name: 'ghcr.io/zaproxy/zaproxy:stable'
  #         cmd_options: '-a'
  #         fail_action: false

  deploy_staging_k8s:
    runs-on: ubuntu-latest
    needs: build_and_docker

    steps:
      - uses: actions/checkout@v4

      - name: Create kind cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: staging

      - name: Build Docker image
        run: |
          docker build -t collector-api:ci .

      - name: Load image into kind
        run: |
          kind load docker-image collector-api:ci --name staging

      - name: Deploy to Kubernetes (staging)
        shell: bash
        run: |
          set -e
          kubectl apply -f k8s/staging.yaml

          kubectl -n staging rollout status deploy/postgres --timeout=180s
          kubectl -n staging rollout status deploy/api --timeout=180s

          kubectl -n staging wait --for=condition=Ready pod -l app=postgres --timeout=180s
          kubectl -n staging wait --for=condition=Ready pod -l app=api --timeout=180s

      - name: Smoke test API (inside cluster, no port-forward)
        shell: bash
        run: |
          set -e
          kubectl -n staging run curltest --rm -i --restart=Never \
            --image=curlimages/curl:8.5.0 \
            --command -- sh -lc '
              for i in $(seq 1 20); do
                code=$(curl -s -o /dev/null -w "%{http_code}" http://api:4000/articles || true)
                echo "try $i => HTTP $code"
                if [ "$code" != "000" ]; then
                  echo "API reachable (HTTP $code)"
                  exit 0
                fi
                sleep 2
              done
              echo "API not reachable"
              exit 1
            '
  deploy_staging_https_test:
    name: Deploy staging (HTTPS test) - TEMP
    runs-on: ubuntu-latest
    needs: deploy_staging_k8s
    steps:
      - uses: actions/checkout@v4

      - name: Create kind cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: staging

      - name: Build + Load + Deploy app
        shell: bash
        run: |
          set -e
          docker build -t collector-api:ci .
          kind load docker-image collector-api:ci --name staging
          kubectl apply -f k8s/staging.yaml
          kubectl -n ${{ env.K8S_NAMESPACE }} rollout status deploy/api --timeout=180s
          kubectl -n ${{ env.K8S_NAMESPACE }} wait --for=condition=Ready pod -l app=api --timeout=180s

      - name: Install Ingress NGINX (Kind)
        shell: bash
        run: |
          set -e
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.11.3/deploy/static/provider/kind/deploy.yaml
          kubectl -n ingress-nginx rollout status deploy/ingress-nginx-controller --timeout=240s

      - name: Create self-signed TLS cert (TEMP)
        shell: bash
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y openssl

          # CN/Host utilisé par l’Ingress
          HOST=api.staging.local

          openssl req -x509 -nodes -days 2 -newkey rsa:2048 \
            -keyout tls.key -out tls.crt \
            -subj "/CN=${HOST}/O=collector"

          kubectl -n ${{ env.K8S_NAMESPACE }} delete secret api-tls --ignore-not-found
          kubectl -n ${{ env.K8S_NAMESPACE }} create secret tls api-tls --cert=tls.crt --key=tls.key

      - name: Apply HTTPS Ingress (TEMP)
        shell: bash
        run: |
          set -e
          cat <<'EOF' | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: api-https
            namespace: staging
            annotations:
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            ingressClassName: nginx
            tls:
              - hosts:
                  - api.staging.local
                secretName: api-tls
            rules:
              - host: api.staging.local
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: api
                          port:
                            number: 4000
          EOF

      - name: HTTPS smoke test (via port-forward) - TEMP
        shell: bash
        run: |
          set -e

          # Port-forward sur le contrôleur ingress en 8443 local
          kubectl -n ingress-nginx port-forward svc/ingress-nginx-controller 8443:443 >/tmp/pf.log 2>&1 &
          PF_PID=$!
          sleep 3

          # Test HTTPS (cert auto-signé => -k) + Host header
          for i in $(seq 1 20); do
            code=$(curl -k -s -o /dev/null -w "%{http_code}" https://127.0.0.1:8443/articles -H "Host: api.staging.local" || true)
            echo "try $i => HTTPS $code"
            if [ "$code" != "000" ] && [ "$code" != "404" ]; then
              echo "HTTPS reachable (HTTP $code)"
              kill $PF_PID || true
              exit 0
            fi
            sleep 2
          done

          echo "HTTPS not reachable"
          kill $PF_PID || true
          exit 1
