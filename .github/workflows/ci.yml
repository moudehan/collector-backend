name: CI-CD Backend

on:
  push:
    branches: ['master']
  pull_request:
    branches: ['master']

jobs:
  quality_and_build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci


      - name: Lint
        run: npm run lint

      - name: Type check
        run: npx tsc --noEmit

  tests:
    runs-on: ubuntu-latest
    needs: quality_and_build

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: collector_test
          POSTGRES_PASSWORD: collector_test
          POSTGRES_DB: collector_test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U collector_test -d collector_test_db"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    env:
      KEYCLOAK_ISSUER: http://localhost:8081/realms/collector
      KEYCLOAK_CLIENT_ID: collector-api
      KEYCLOAK_CLIENT_SECRET: dummy-secret

      DB_HOST: 127.0.0.1
      DB_PORT: "5432"
      DB_USER: collector_test
      DB_PASSWORD: collector_test
      DB_NAME: collector_test_db

      NODE_ENV: test

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm ci

      - name: Wait for Postgres
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          for i in {1..30}; do
            pg_isready -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" && exit 0
            echo "Postgres not ready yet... ($i/30)"
            sleep 2
          done
          echo "Postgres did not become ready in time" && exit 1

      - name: Unit tests
        run: npm test

      - name: E2E API tests
        run: npm run test:e2e

  security:
    runs-on: ubuntu-latest
    needs: tests
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm ci

      - name: Tests with coverage
        run: npm run test:cov

      - name: SonarQube Cloud Scan
        uses: SonarSource/sonarqube-scan-action@v7
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  build_and_docker:
    runs-on: ubuntu-latest
    needs: security
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm ci

      - name: Build app
        run: npm run build

      - name: Build Docker image
        run: |
          docker build -t ghcr.io/${{ github.repository_owner }}/collector-api:${{ github.sha }} .
          # docker push ghcr.io/${{ github.repository_owner }}/collector-api:${{ github.sha }}

  # charge_test:
  #   runs-on: ubuntu-latest
  #   # needs: build_and_docker
  #   env:
  #     TARGET_URL: http://localhost:4000
  #     KEYCLOAK_ISSUER: http://localhost:8081/realms/collector
  #     KEYCLOAK_CLIENT_ID: collector-api
  #     KEYCLOAK_CLIENT_SECRET: ${{ secrets.KEYCLOAK_CLIENT_SECRET }}
  #   steps:
  #     - name: Install siege and jq
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y siege jq

  #     - name: Create Siege URL file
  #       run: |
  #         cat > siege-urls.txt <<EOF
  #         ${TARGET_URL}/users
  #         ${TARGET_URL}/notifications/my
  #         ${TARGET_URL}/articles
  #         EOF

  #             - name: Get access token from Keycloak
  #               run: |
  #                 TOKEN=$(curl -s \
  #                   -H "Content-Type: application/x-www-form-urlencoded" \
  #                   -d "client_id=${KEYCLOAK_CLIENT_ID}" \
  #                   -d "client_secret=${KEYCLOAK_CLIENT_SECRET}" \
  #                   -d "grant_type=client_credentials" \
  #                   "${KEYCLOAK_ISSUER}/protocol/openid-connect/token" \
  #                   | jq -r .access_token)

  #                 echo "TOKEN=$TOKEN"
  #                 echo "TOKEN=$TOKEN" >> $GITHUB_ENV

  #             - name: Run load tests on multiple API endpoints
  #               run: |
  #                 echo "Running load tests on endpoints from siege-urls.txt..."
  #                 siege -c 3 -t1M \
  #                   -H "Authorization: Bearer $TOKEN" \
  #                   -H "Content-Type: application/json" \
  #                   -f siege-urls.txt

  # owasp_zap:
  #   runs-on: ubuntu-latest
  #   # needs: charge_test
  #   env:
  #     API_PORT: 4000
  #     API_BASE_URL: http://localhost:4000
  #     KEYCLOAK_HOST: collector-keycloak
  #     KEYCLOAK_HTTP_PORT: 8080
  #     KEYCLOAK_ISSUER: http://collector-keycloak:8080/realms/collector
  #     KEYCLOAK_CLIENT_ID: collector-api
  #     KEYCLOAK_CLIENT_SECRET: ${{ secrets.KEYCLOAK_CLIENT_SECRET }}
  #     DB_HOST: collector-postgres
  #     DB_PORT: 5432
  #     DB_USER: collector_user
  #     DB_PASSWORD: collector_password
  #     DB_NAME: collector_db
  #   steps:
  #     - name: Checkout
  #     # ton code
  #       uses: actions/checkout@v4

  #     - name: Build API Docker image
  #       run: |
  #         docker build -t collector-api:${{ github.sha }} .

  #     - name: Create CI Docker network
  #       run: |
  #         docker network create ci-net

  #     - name: Run Postgres for API & Keycloak
  #       run: |
  #         docker run -d --name collector-postgres \
  #           --network ci-net \
  #           -e POSTGRES_USER=${DB_USER} \
  #           -e POSTGRES_PASSWORD=${DB_PASSWORD} \
  #           -e POSTGRES_DB=${DB_NAME} \
  #           -p 5433:5432 \
  #           postgres:14

  #     - name: Run Keycloak
  #       run: |
  #         docker run -d --name collector-keycloak \
  #           --network ci-net \
  #           -e KEYCLOAK_ADMIN=admin \
  #           -e KEYCLOAK_ADMIN_PASSWORD=admin \
  #           -e KC_DB=postgres \
  #           -e KC_DB_URL_HOST=${DB_HOST} \
  #           -e KC_DB_URL_DATABASE=${DB_NAME} \
  #           -e KC_DB_USERNAME=${DB_USER} \
  #           -e KC_DB_PASSWORD=${DB_PASSWORD} \
  #           -e KC_HOSTNAME=${KEYCLOAK_HOST} \
  #           -p 8081:8080 \
  #           quay.io/keycloak/keycloak:24.0.5 \
  #           start-dev

  #         echo "Waiting for Keycloak..."
  #         curl --fail --retry 20 --retry-all-errors --retry-delay 5 \
  #           http://localhost:8081/realms/master/.well-known/openid-configuration

  #     - name: Run API container for ZAP
  #       run: |
  #         docker run -d --name collector-api \
  #           --network ci-net \
  #           -p ${API_PORT}:4000 \
  #           -e PORT=${API_PORT} \
  #           -e DB_HOST=${DB_HOST} \
  #           -e DB_PORT=${DB_PORT} \
  #           -e DB_USER=${DB_USER} \
  #           -e DB_PASSWORD=${DB_PASSWORD} \
  #           -e DB_NAME=${DB_NAME} \
  #           -e KEYCLOAK_ISSUER=${KEYCLOAK_ISSUER} \
  #           -e KEYCLOAK_JWKS_URI=${KEYCLOAK_ISSUER}/protocol/openid-connect/certs \
  #           -e KEYCLOAK_AUDIENCE=${KEYCLOAK_CLIENT_ID} \
  #           collector-api:${{ github.sha }}

  #         echo "Waiting for API to be up..."
  #         curl --fail --retry 20 --retry-all-errors --retry-delay 5 \
  #           ${API_BASE_URL}/health

  #     - name: Install jq
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y jq

  #     - name: Get Keycloak token for ZAP (client_credentials)
  #       run: |
  #         TOKEN=$(curl -s \
  #           -H "Content-Type: application/x-www-form-urlencoded" \
  #           -d "client_id=${KEYCLOAK_CLIENT_ID}" \
  #           -d "client_secret=${KEYCLOAK_CLIENT_SECRET}" \
  #           -d "grant_type=client_credentials" \
  #           "http://localhost:8081/realms/collector/protocol/openid-connect/token" \
  #           | jq -r .access_token)

  #         echo "TOKEN=$TOKEN" >> $GITHUB_ENV

  #     - name: OWASP ZAP baseline scan (secured endpoints)
  #       uses: zaproxy/action-baseline@v0.15.0
  #       env:
  #         ZAP_AUTH_HEADER: Authorization
  #         ZAP_AUTH_HEADER_VALUE: Bearer ${{ env.TOKEN }}
  #       with:
  #         target: '${{ env.API_BASE_URL }}/articles'
  #         docker_name: 'ghcr.io/zaproxy/zaproxy:stable'
  #         cmd_options: '-a'
  #         fail_action: false


  deploy_staging_k8s:
    runs-on: ubuntu-latest
    needs: build_and_docker

    steps:
      - uses: actions/checkout@v4

      - name: Create kind cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: staging

      - name: Build Docker image
        run: |
          docker build -t collector-api:ci .

      - name: Load image into kind
        run: |
          kind load docker-image collector-api:ci --name staging

      - name: Deploy to Kubernetes (staging)
        run: |
          kubectl apply -f k8s/staging.yaml
          kubectl -n staging rollout status deploy/postgres --timeout=120s
          kubectl -n staging rollout status deploy/api --timeout=120s

      - name: Smoke test API (inside cluster)
        shell: bash
        run: |
          kubectl -n staging get pods -l app=api -o wide
          kubectl -n staging wait --for=condition=Ready pod -l app=api --timeout=180s

          kubectl -n staging run curltest --rm -i --restart=Never \
            --image=curlimages/curl:8.5.0 \
            --command -- sh -lc '
              code=$(curl -s -o /dev/null -w "%{http_code}" http://api:4000/ || true);
              echo "HTTP=$code";
              [ "$code" != "000" ]
           '


    # deploy_prod:
    #   runs-on: ubuntu-latest
    #   needs: e2e_and_load_tests
    #   if: github.ref == 'refs/heads/main'
    #   environment:
    #     name: production
    #     url: https://api.collector.shop
  #   steps:
  #     - name: Manual approval gate
  #       run: echo "Cette étape nécessite l'approbation manuelle dans GitHub (environnement 'production')."

  #     - name: Deploy to prod
  #       run: |
  #         kubectl apply -f k8s/deployment-api-prod.yaml
